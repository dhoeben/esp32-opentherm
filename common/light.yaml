light:
  - platform: esp32_rmt_led_strip
    id: onboard_led
    internal: true
    name: "Status LED"
    pin: GPIO48
    num_leds: 1
    default_transition_length: 0s
    rgb_order: GRB
    chipset: WS2812
    effects:
      - addressable_rainbow:
          name: "Rainbow"
          speed: 10
          width: 25

interval:
  - interval: 1s
    then:
      - lambda: |-
          // Boot phase (first 10 s): solid green overrides everything
          if (millis() < 10000) {
            auto call = id(onboard_led).turn_on();
            call.set_rgb(0.0f, 1.0f, 0.0f);   // ðŸŸ¢
            call.perform();
            return;
          }

          // Determine which errors are active
          bool has_fault   = id(boiler_fault).state;
          bool wifi_down   = !id(wifi_connected).state;
          bool comm_error  = !id(comms_ok).state;
          bool emergency   = id(emergency_mode).state;
          bool backup_mode = id(backup_temp_switch).state;

          // Overruling modes
          bool developer   = id(developer_mode_switch).state;
          bool rainbow     = id(led_rainbow_mode).state;

          // If nothing active â†’ LED off
          if (!has_fault && !wifi_down && !comm_error && !emergency) {
            id(onboard_led).turn_off().perform();
            return;
          }

          if (!developer || !rainbow) {
            // ---- Blink sequence between active states ----
            // Order: red (fault) â†’ blue (wifi) â†’ purple (comms) â†’ orange (emergency) â†’ white (backup)
            static int step = 0;
            step = (step + 1) % 5; 

            auto call = id(onboard_led).turn_on();

            if (has_fault && step == 0) {
              call.set_rgb(1.0f, 0.0f, 0.0f);  // ðŸ”´
              call.perform();
              return;
            }

            if (wifi_down && step == 1) {
              call.set_rgb(0.0f, 0.0f, 1.0f);  // ðŸ”µ
              call.perform();
              return;
            }

            if (comm_error && step == 2) {
              call.set_rgb(0.5f, 0.0f, 0.5f);  // ðŸŸ£
              call.perform();
              return;
            }

            if (emergency && step == 3) {
              call.set_rgb(1.0f, 0.5f, 0.0f);  // ðŸŸ 
              call.perform();
              return;
            }

            if (backup_mode && step == 4) {
              call.set_rgb(1.0f, 1.0f, 1.0f);  // âšª 
              call.perform();
              return;
            }

            // Nothing shown this tick â†’ turn off to create visible blinking
            id(onboard_led).turn_off().perform();
          }